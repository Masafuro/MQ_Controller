# タイトル: オープンMQTTブローカーと複雑トピック名によるセキュリティ対策

## 概要:
MQTTブローカーをオープンに公開し、ユーザー認証を行わずに多クライアント間のセキュアな通信を実現するための構成。
通信の秘匿性と分離性は、トピック名の構造的難読性と時限性によって確保される。

- 2025-06-15 9:06
    - 時間制限は廃止する。理由、uuid+secretsの強度が十分にあれば、ブラウザで読み込みする度に生成されるIDであるため、十分な強度があるのではないか？

## 基本原則:
- MQTTブローカーへの接続は誰にでも許可されている（認証なし）
- ただし、特定のユーザー専用のトピックは、知っている者のみがアクセスできる
- セキュリティの中核は「トピック名の予測不能性」と「短命性」

### トピック構成例:
client/{uuid}-{secret}/t{timestamp}/status

### 例:
client/76a9b82f-b7f0-4fda-9a2f-1dd3eebcc417-FHj3kl82gE43eM1f/t20240615T1600/status

### 各要素の説明:
- uuid: クライアントごとに一意な識別子（UUIDv4推奨）
- secret: ランダムな文字列（20〜32文字程度、Base64URLなど）
- timestamp: トピックの有効期限を示す（例: "20240615T1600"）
- status: 通信種別のサフィックス（"status", "cmd" など）

## トピックの特性:
- 推測不能（uuid + secret + timestamp で200bit以上のエントロピー）
- 存在が知られていない限りアクセス不可能
- 30分ごとに新しいトピックに切り替わる（使い捨て）
- 過去のトピックは保持されず、retainフラグは使用しない
- ワイルドカード（# や +）によるsubscribeは禁止

## UUID + secretの生成について:
- 通常はバックエンドで生成する手法が一般的とされるが、この方式では「鍵」が公開される構造ではないため、JavaScript側でUUID + secretを生成してもセキュリティ上問題はない。
- 重要なのは、生成されたトピック名が第三者に知られないこと、かつ短命であることである。
- JavaScriptでランダムなUUIDとsecretを生成し、その場限りのトピックとして利用することで、十分な秘匿性が保たれる。

## セキュリティ対策要点:
- トピック名自体が「鍵」として機能する
- 通信はWSS（TLS）で暗号化されているため、盗聴不可能
- 攻撃者はトピック名を知らなければsubscribeできない
- トピックが短命であるため、漏洩しても影響が限定的
- 総当たり攻撃（量子含む）にも耐えるエントロピーを保持
- MQTTブローカー側でワイルドカードsubscribeを制限（ACL設定推奨）

## 応用・拡張案:
- timestampによりスロット制御を行い、より厳密な有効期限判定を導入
- secretを HMAC(uuid + timestamp) などの導出方式に変更し、衝突・推測をさらに困難化
- ブローカーにログを残し、アクセス監視を追加

## まとめ:
この方式は、ユーザー認証を用いず、かつ中央集権的な管理サーバーを設けずに、実質的に安全なプライベート通信チャネルをMQTT上に構築する方法である。
secretの発行主体がクライアントであっても安全性は維持され、全体として非常にシンプルかつ堅牢なセキュリティ構成が成立している。
攻撃を受けにくく、かつスケーラブルなため、小規模なWebアプリからIoTネットワークまで幅広く適用可能である。
